#! /bin/bash

trap "echo Exiting..." SIGINT SIGTERM

declare -a BUILD_FILES=($(readlink -f $0))
readonly TOP_SOURCE_DIR=$(dirname ${BUILD_FILES[0]})
readonly SYSTEM=$(uname -s)
readonly ARCH=$(uname -m)
readonly FLAVOR=$(lsb_release -s -i)

echo "Configuring for $SYSTEM, $ARCH, $FLAVOR"

declare BUILD_TYPE=$1
declare OUTPUT_ROOT=${TOP_SOURCE_DIR}

declare -a ALL_TARGETS
declare -A OUTPUT_DIRS
declare -A TARGET_INFO
declare -a SCOPED_VARS
declare -a SCOPED_ARRAYS
declare -a EMITTER_SETUP_FUNCS
declare -a EMITTER_TARGET_FUNCS
declare -a TOP_LEVEL_FUNCS
declare EMITTER_STYLE=ninja

function SetEmitter
{
	EMITTER_STYLE=$1
}

function OutputRoot
{
	OUTPUT_ROOT=$1
}

function BuildType
{
	OUTPUT_DIRS[$1]=$2
}

function DefaultBuildType
{
	if [ -z "${BUILD_TYPE}" ]
	then
		BUILD_TYPE=$1
	fi
}

function Building
{
	if [ "${BUILD_TYPE}" == "$1" ]
	then
		return 0
	fi
	return 1
}

function FindExecutable
{
	local __t=$(type -p $1)
	if [ -z "$__t" ]
	then
		__t=$(type -t $1)
		if [ -z "$__t" ]
		then
			echo "ERROR: Unable to find executable or shell builtin/alias '$1'"
			exit 1
		fi
	fi

	eval $2=$__t
}

function LocalVar
{
	LOCAL_VARS[$1]=$2
}

function DefineExecutable
{
	local __e
	FindExecutable $2 __e
	LocalVar $1 $__e
}

function AddRuleFile
{
	if [ ${1:0:1} = '/' ]
	then
		LOCAL_RULE_FILES+=($1)
	else
		LOCAL_RULE_FILES+=(${TOP_SOURCE_DIR}${CURRENT_DIR}$1)
	fi
}

function __write_ninja
{
	local cur_NINJA_FILE=${CURRENT_BINARY_DIR}build.ninja

	truncate --size=0 $cur_NINJA_FILE

	if [ "$1" == t ]
	then
		echo "build always: phony" >> $cur_NINJA_FILE
	fi

	for i in "${LOCAL_RULE_FILES[@]}"
	do
		echo "include $i" >> $cur_NINJA_FILE
	done

	for i in "${!LOCAL_VARS[@]}"
	do
		echo "$i = ${LOCAL_VARS[$i]}" >> $cur_NINJA_FILE
	done

	for __emitter in "${EMITTER_SETUP_FUNCS[@]}"
	do
		eval $__emitter $cur_NINJA_FILE $2
	done

	for __emitter in "${EMITTER_TARGET_FUNCS[@]}"
	do
		eval $__emitter $cur_NINJA_FILE $2
	done

	for i in "${SUBDIRS_VISITED[@]}"
	do
		echo "subninja ${CURRENT_BINARY_DIR}$i/build.ninja" >> $cur_NINJA_FILE
	done

	if [ "$1" == t ]
	then
		# emit the "all targets" rule
		echo "build all: phony ${ALL_TARGETS[@]}" >> $cur_NINJA_FILE

		# emit the rule to re-generate ourselves
		echo -e "\nrule rerun_configure\n  command = ${BUILD_FILES[0]} ${BUILD_TYPE}\n  description = Re-running configuration...\n  generator = 1\n" >> $cur_NINJA_FILE
		echo "build build.ninja: rerun_configure | ${BUILD_FILES[@]}" >> $cur_NINJA_FILE
	fi
}

function OutputBuildFile
{
	if [ $2 == t ]
	then
		if [ -z "${OUTPUT_DIRS[${BUILD_TYPE}]}" ]
		then
			echo "ERROR: Build type '${BUILD_TYPE}' not defined"
			exit 1
		fi
	fi

	local CURRENT_BINARY_DIR=${OUTPUT_ROOT}/${OUTPUT_DIRS[${BUILD_TYPE}]}$1
	mkdir -p $CURRENT_BINARY_DIR
	
	case $EMITTER_STYLE in
		ninja)
			__write_ninja $2
			;;
		*)
			echo "ERROR: Unknown emitter for CPP rules"
			exit 1
			;;
	esac
}

function ProcessDirectory
{
	local CURRENT_DIR=${CURRENT_DIR}$1/
	local tmpFILE=${TOP_SOURCE_DIR}${CURRENT_DIR}build.txt

	local CURRENT_SOURCE_PATH=${TOP_SOURCE_DIR}${CURRENT_DIR}

	local __topLevel=f
	if [ -z "$1" ]
	then
		__topLevel=t
	fi

	if [ -e $tmpFILE ]
	then
		BUILD_FILES+=($tmpFILE)
		local -A LOCAL_VARS
		local -a LOCAL_RULE_FILES
		local -a SUBDIRS_VISITED

		for __v in "${SCOPED_VARS[@]}"
		do
# preserve old values or not???
#			eval local $__v=\$$__v
			eval local $__v=""
		done
		for __v in "${SCOPED_ARRAYS[@]}"
		do
# preserve old values or not???
#			eval local -a $__v=(\${$__v[@]})
			eval local -a ${__v}
		done

		source $tmpFILE || exit 1

		if [ $__topLevel == t ]
		then
			for __tl in "${TOP_LEVEL_FUNCS[@]}"
			do
				eval $__tl
			done
		fi

		OutputBuildFile $CURRENT_DIR $__topLevel

		unset LOCAL_VARS
		unset LOCAL_RULE_FILES
		unset SUBDIRS_VISITED

		for __v in "${SCOPED_VARS[@]}"
		do
			eval unset $__v
		done
		for __v in "${SCOPED_ARRAYS[@]}"
		do
			eval unset $__v
		done
	else
		echo "ERROR: No build file '${2}' found in directory '${1}'"
		exit 1
	fi
	unset tmpFILE
}

function SubDir
{
	SUBDIRS_VISITED+=("$@")
	for s in "$@"
	do
		ProcessDirectory ${s}
	done
}


##############################
## Module support
##############################


function ModuleScopedArrays
{
	SCOPED_ARRAYS+=("$@")
}

# NB: indirectly referenced associative arrays seem
# problematic, so see compile_module for a sample
# of getting around it
#function ModuleScopedAssocArrays
#{
#	SCOPED_ASSOC_ARRAYS+=("$@")
#}

function ModuleScopedVars
{
	SCOPED_VARS+=("$@")
}

function ModuleEmitterSetupFunc
{
	EMITTER_SETUP_FUNCS+=("$@")
}

function ModuleEmitterTargetFunc
{
	EMITTER_TARGET_FUNCS+=("$@")
}

# Top Level Funcs are called automagically on the top level
# context prior to writing out any build file for the top level
# but after processing the top level build file
function ModuleTopLevelFunc
{
	TOP_LEVEL_FUNCS+=("$@")
}

##
## Main function to enable a particular handler for a type
## of thing to build
## Include a module enabling another type of configuration
## NB: Only the arguments of the first invocation of
## a module are used, so best to only call this
## once at the top level build.txt file
##
function Module
{
	local __modFile=${TOP_SOURCE_DIR}/config/${1}_module

	if [ -e $__modFile ]
	then
		local __tmpFound=f

		for __i in "${BUILD_FILES[@]}"
		do
			if [ "$__i" == "$__modFile" ]; then
				__tmpFound=t
			fi
		done

		if [ "$__tmpFound" == "f" ]; then
			BUILD_FILES[${#BUILD_FILES[*]}]=$__modFile
			shift
			source $__modFile "$@" || exit 1
		fi
	else
		echo "ERROR: No module file found on config folder for module '${1}'"
		exit 1
	fi
}

ProcessDirectory

echo "Finished generating build files for configuration '$BUILD_TYPE'..."
