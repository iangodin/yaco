#! /bin/bash

trap "echo Exiting..." SIGINT SIGTERM

declare -a BUILD_FILES=($(readlink -f $0))

#echo "Full Configure: ${BUILD_FILES[0]}"
#echo "Full Dir: ${BUILD_FILES[0]%/*}"
#echo "Full Base: ${BUILD_FILES[0]##*/}"
readonly TOP_SOURCE_DIR=${BUILD_FILES[0]%/*}
readonly SYSTEM=$(uname -s)
readonly ARCH=$(uname -m)
if [ ! -z $(type -p lsb_release) ]
then
	readonly FLAVOR=$(lsb_release -s -i)
else
	readonly FLAVOR="*"
fi

declare BUILD_TYPE="$1"
declare TOP_BINARY_DIR
if [ -z "$2" ]
then
	declare OUTPUT_ROOT="${PWD%/$}/"
else
	declare OUTPUT_ROOT="${2%/$}/"
	TOP_BINARY_DIR="${OUTPUT_ROOT}${BUILD_TYPE}/"
fi

declare -a ALL_TARGETS
declare -A OUTPUT_DIRS
declare -A TARGET_INFO
declare -a SCOPED_VARS
declare -a SCOPED_ARRAYS
declare -a EMITTER_SETUP_FUNCS
declare -a EMITTER_TARGET_FUNCS
declare -a PREWRITE_FUNCS
declare -a HEADER_FUNCS
declare EMITTER_STYLE=ninja

function SetEmitter
{
	EMITTER_STYLE=$1
}

function OutputRoot
{
	OUTPUT_ROOT="${1%/$}/"
	if [ ! -z "${BUILD_TYPE}" ]
	then
		TOP_BINARY_DIR="${OUTPUT_ROOT}${OUTPUT_ROOT[${BUILD_TYPE}]}"
		if [ -v CURRENT_BINARY_PATH ]
		then
			CURRENT_BINARY_PATH="${TOP_BINARY_DIR}${CURRENT_DIR}"
		fi
	fi
}

function BuildType
{
	OUTPUT_DIRS[$1]=$2
	if [ "$3" == "DEFAULT" -o -z "${BUILD_TYPE}" ]
	then
		BUILD_TYPE=$1
		TOP_BINARY_DIR="${OUTPUT_ROOT}${2}"
		CURRENT_BINARY_PATH="${TOP_BINARY_DIR}${CURRENT_DIR}"
	fi
}

function Building
{
	if [ "${BUILD_TYPE}" == "$1" ]
	then
		return 0
	fi
	return 1
}

function FindExecutable
{
	local __t=$(type -p $1)
	if [ -z "$__t" ]
	then
		__t=$(type -t $1)
		if [ -z "$__t" ]
		then
			echo "ERROR: Unable to find executable or shell builtin/alias '$1'"
			exit 1
		fi
	fi

	eval $2=$__t
}

function LocalVar
{
	LOCAL_VARS[$1]=$2
}

function DefineExecutable
{
	local __e
	FindExecutable $2 __e
	LocalVar $1 $__e
}

function AddRuleFile
{
	if [ ${1:0:1} = '/' ]
	then
		LOCAL_RULE_FILES+=($1)
	else
		LOCAL_RULE_FILES+=(${TOP_SOURCE_DIR}${CURRENT_DIR}$1)
	fi
}

function __write_ninja_header_footer
{
	local __nFile=$1
	local __topLevel=$2
	local __type=$3

	if [ "$__topLevel" == t ]
	then
		case "$__type" in
			header)
				echo "build always: phony" >> "${__nFile}"
				;;
			footer)
				# emit the "all targets" rule
				echo "build all: phony ${ALL_TARGETS[@]}" >> "${__nFile}"

				# emit the rule to re-generate ourselves
				echo -e "\nrule rerun_configure\n  command = ${BUILD_FILES[0]} ${BUILD_TYPE} ${OUTPUT_ROOT}\n  description = Re-running configuration...\n  generator = 1\n" >> "${__nFile}"
				echo "build build.ninja: rerun_configure | ${BUILD_FILES[@]}" >> "${__nFile}"
				;;
			*)
				echo "ERROR: Unknow header / footer tag"
				exit 1
				;;
		esac				
	fi
}

function __write_ninja
{
	local cur_NINJA_FILE=${CURRENT_BINARY_PATH}build.ninja

	truncate --size=0 $cur_NINJA_FILE

	for __f in "${HEADER_FUNCS[@]}"
	do
		eval $__f "${cur_NINJA_FILE}" $1 header
	done

	for i in "${LOCAL_RULE_FILES[@]}"
	do
		echo "include $i" >> "$cur_NINJA_FILE"
	done

	for i in "${!LOCAL_VARS[@]}"
	do
		echo "$i = ${LOCAL_VARS[$i]}" >> "$cur_NINJA_FILE"
	done

	for __emitter in "${EMITTER_SETUP_FUNCS[@]}"
	do
		eval $__emitter "$cur_NINJA_FILE" $1
	done

	for __emitter in "${EMITTER_TARGET_FUNCS[@]}"
	do
		eval $__emitter "$cur_NINJA_FILE" $1
	done

	for i in "${SUBDIRS_VISITED[@]}"
	do
		echo "subninja ${CURRENT_BINARY_PATH}$i/build.ninja" >> "$cur_NINJA_FILE"
	done

	for __f in "${HEADER_FUNCS[@]}"
	do
		eval $__f "$cur_NINJA_FILE" $1 footer
	done
}

function __MAIN_HeaderFooter
{
	case $EMITTER_STYLE in
		ninja)
			__write_ninja_header_footer "$@"
			;;
		*)
			echo "ERROR: Unknown emitter for configure rules"
			exit 1
			;;
	esac
}

function OutputBuildFile
{
	if [ $2 == t ]
	then
		if [ -z "${OUTPUT_DIRS[${BUILD_TYPE}]}" ]
		then
			echo "ERROR: Build type '${BUILD_TYPE}' not defined"
			exit 1
		fi
	fi

	mkdir -p $CURRENT_BINARY_PATH
	
	case $EMITTER_STYLE in
		ninja)
			__write_ninja $2
			;;
		*)
			echo "ERROR: Unknown emitter for configure rules"
			exit 1
			;;
	esac
}

function ProcessDirectory
{
	local CURRENT_DIR="${CURRENT_DIR}$1/"
	local tmpFILE="${TOP_SOURCE_DIR}${CURRENT_DIR}build.txt"

	local CURRENT_SOURCE_PATH="${TOP_SOURCE_DIR}${CURRENT_DIR}"
	local CURRENT_BINARY_PATH
	if [ ! -z "${TOP_BINARY_DIR}" ]
	then
		CURRENT_BINARY_PATH="${TOP_BINARY_DIR}${CURRENT_DIR}"
	fi

	local __topLevel=f
	if [ -z "$1" ]
	then
		__topLevel=t
	fi

	if [ -e $tmpFILE ]
	then
		BUILD_FILES+=($tmpFILE)
		local -A LOCAL_VARS
		local -a LOCAL_RULE_FILES
		local -a SUBDIRS_VISITED

		for __v in "${SCOPED_VARS[@]}"
		do
# preserve old values or not???
#			eval local $__v=\$$__v
			eval local $__v=""
		done
		for __v in "${SCOPED_ARRAYS[@]}"
		do
# preserve old values or not???
#			eval local -a $__v=(\${$__v[@]})
			eval local -a ${__v}
		done

		source $tmpFILE || exit 1

		if [ $__topLevel == t ]
		then
			for __tl in "${PREWRITE_FUNCS[@]}"
			do
				eval $__tl start
			done
		fi

		OutputBuildFile $CURRENT_DIR $__topLevel

		unset LOCAL_VARS
		unset LOCAL_RULE_FILES
		unset SUBDIRS_VISITED

		for __v in "${SCOPED_VARS[@]}"
		do
			eval unset $__v
		done
		for __v in "${SCOPED_ARRAYS[@]}"
		do
			eval unset $__v
		done
	else
		echo "ERROR: No build file '${2}' found in directory '${1}'"
		exit 1
	fi
	unset tmpFILE
}

function SubDir
{
	SUBDIRS_VISITED+=("$@")
	for s in "$@"
	do
		ProcessDirectory ${s}
	done
}


##############################
## Module support
##############################


function ModuleScopedArrays
{
	SCOPED_ARRAYS+=("$@")
}

# NB: indirectly referenced associative arrays seem
# problematic, so see compile_module for a sample
# of getting around it
#function ModuleScopedAssocArrays
#{
#	SCOPED_ASSOC_ARRAYS+=("$@")
#}

function ModuleScopedVars
{
	SCOPED_VARS+=("$@")
}

function ModuleEmitterSetupFunc
{
	EMITTER_SETUP_FUNCS+=("$@")
}

function ModuleEmitterTargetFunc
{
	EMITTER_TARGET_FUNCS+=("$@")
}

# Pre-write Funcs are called automagically on the top level
# context prior to writing out any build file for the top level
# but after processing the top level build file. NB: may be
# after other config files have been written
function ModuleStartWriteFunc
{
	PREWRITE_FUNCS+=( "$@" )
}

function ModuleHeaderWriteFunc
{
	# Make it so the main one runs last...
	if [ ${#HEADER_FUNCS[@]} -gt 0 ]
	then
		HEADER_FUNCS=( "$@" ${HEADER_FUNCS[@]} )
	else
		HEADER_FUNCS+=( "$@" )
	fi
}

##
## Main function to enable a particular handler for a type
## of thing to build
## Include a module enabling another type of configuration
## NB: Only the arguments of the first invocation of
## a module are used, so best to only call this
## once at the top level build.txt file
##
function Module
{
	local __modFile=${TOP_SOURCE_DIR}/config/${1}_module

	if [ -e $__modFile ]
	then
		local __tmpFound=f

		for __i in "${BUILD_FILES[@]}"
		do
			if [ "$__i" == "$__modFile" ]; then
				__tmpFound=t
			fi
		done

		if [ "$__tmpFound" == "f" ]; then
			BUILD_FILES[${#BUILD_FILES[*]}]=$__modFile
			shift
			source $__modFile "$@" || exit 1
		fi
	else
		echo "ERROR: No module file found on config folder for module '${1}'"
		exit 1
	fi
}

ModuleHeaderWriteFunc __MAIN_HeaderFooter

ProcessDirectory

